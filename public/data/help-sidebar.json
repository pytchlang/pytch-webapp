[
    {
        "kind": "heading",
        "sectionSlug": "motion",
        "heading": "Motion"
    },
    {
        "kind": "block",
        "python": "self.turn_degrees(angle)",
        "scratch": "turn ccw [90] degrees",
        "help": "**Sprites only:** Turn the `self` Sprite `angle` degrees anticlockwise (counter-clockwise).  To turn clockwise, use a negative number for `angle`.\n\n```\n# Turn a quarter-turn anticlockwise:\nself.turn_degrees(90)\n```"
    },
    {
        "kind": "block",
        "python": "self.point_degrees(angle)",
        "scratch": "point in direction [-45]",
        "help": "**Sprites only:** Turn the `self` Sprite to point in the direction given by `angle`, which measures degrees anticlockwise (counter-clockwise) from its original orientation.  To give a direction in terms of rotation clockwise, use a negative value for `angle`.\n\n```\n# Point (1/8)th turn clockwise\n# compared to original costume:\nself.point_degrees(-45)\n```"
    },
    {
        "kind": "block",
        "python": "self.go_to_xy(x, y)",
        "scratch": "go to x: [-200] y: [150]",
        "help": "**Sprites only:** Move the `self` Sprite to the position (`x`, `y`) on the Stage.\n\n```\n# Move to near top left:\nself.go_to_xy(-200, 150)\n```"
    },
    {
        "kind": "block",
        "python": "self.glide_to_xy(x, y, seconds)",
        "scratch": "glide [2.5] secs to x: [0] y: [0]",
        "help": "**Sprites only:** Glide the `self` Sprite smoothly to the position (`x`, `y`) on the stage.  The movement will take `seconds` seconds.\n\n```\n# Take 2½ seconds to move smoothly\n# to the centre of the stage:\nself.glide_to_xy(0, 0, 2.5)\n```"
    },
    {
        "kind": "block",
        "python": "self.change_x(dx)",
        "scratch": "change x by [-20]",
        "help": "**Sprites only:** Move the `self` Sprite horizontally by `dx`.  If `dx` is positive, move right; if `dx` is negative, move left.\n\n```\n# Move left a bit:\nself.change_x(-20)\n```"
    },
    {
        "kind": "block",
        "python": "self.set_x(x)",
        "scratch": "set x to [-220]",
        "help": "**Sprites only:** Move the `self` Sprite horizontally to the `x` position.\n\n```\n# Move horizonally to near the\n# left edge of the stage:\nself.set_x(-220)\n```"
    },
    {
        "kind": "block",
        "python": "self.change_y(dy)",
        "scratch": "change y by [25]",
        "help": "**Sprites only:** Move the `self` Sprite vertically by `dy`.  If `dy` is positive, move up; if `dy` is negative, move down.\n\n```\n# Move up a bit:\nself.change_y(25)\n```"
    },
    {
        "kind": "block",
        "python": "self.set_y(y)",
        "scratch": "set y to [-150]",
        "help": "**Sprites only:** Move the `self` Sprite vertically to the `y` position.\n\n```\n# Move vertically to near bottom\n# of stage:\nself.set_y(-150)\n```"
    },
    {
        "kind": "block",
        "python": "self.x_position",
        "scratch": "(x position)",
        "help": "**Sprites only:** The horizontal position (`x` coordinate) of the `self` Sprite.\n\n```\n# Say how far left/right I am:\nself.say(self.x_position)\n```"
    },
    {
        "kind": "block",
        "python": "self.y_position",
        "scratch": "(y position)",
        "help": "**Sprites only:** The vertical position (`y` coordinate) of the `self` Sprite.\n\n```\n# Print how low/high I am to\n# \"Output\" pane:\nprint(self.y_position)\n```"
    },
    {
        "kind": "block",
        "python": "self.direction",
        "scratch": "(direction)",
        "help": "**Sprites only:** The direction the `self` Sprite is currently pointing, measured in degrees anticlockwise (counterclockwise) from its original orientation.\n\n```\n# Say what direction I'm pointing:\nself.say(self.direction)\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "looks",
        "heading": "Looks"
    },
    {
        "kind": "block",
        "python": "self.say_for_seconds(text, seconds)",
        "scratch": "say [Apple!] for [2] seconds",
        "help": "**Sprites only:** Show a speech bubble for the `self` Sprite, saying `text`, lasting for `seconds` seconds.\n\n```\n# Ask nicely for an apple:\nself.say_for_seconds(\"Apple!\", 2)\nself.say_for_seconds(\"Please?\", 2)\n```"
    },
    {
        "kind": "block",
        "python": "self.say(text)",
        "scratch": "say [Hello world!]",
        "help": "**Sprites only:** Show a speech bubble for the `self` Sprite, saying `text`.\n\n```\n# Greet everyone:\nself.say(\"Hello world!\")\n```\n\nIf `text` is the empty string, remove the speech bubble for the `self` Sprite.  If the Sprite doesn't currently have a speech bubble, do nothing.\n\n```\n# Stop talking:\nself.say(\"\")\n```"
    },
    {
        "kind": "block",
        "python": "self.switch_costume(name_or_index)",
        "scratch": "switch costume to (smiling v)",
        "help": "**Sprites only:** Switch to one of the costumes listed in this Sprite's *Costumes* variable.  You can do this either by giving the costume's *name*, or its *number*.\n\n```\n# Switch to smiling costume:\nself.switch_costume(\"smiling\")\n```\n\nIf you want to use a *number* to say which costume, remember that Python starts counting entries in a list at *zero*.\n\n```\n# Switch to first costume:\nself.switch_costume(0)\n```\n\n```\n# Switch to second costume:\nself.switch_costume(1)\n```"
    },
    {
        "kind": "block",
        "python": "self.switch_backdrop(name_or_index)",
        "scratch": "switch backdrop to (sunny v)",
        "help": "**Stage only:** Switch to one of the backdrops listed in your Stage's *Backdrops* variable.  You can do this either by giving the costume's *name*, or its *number*.\n\n```\n# Switch to sunny backdrop:\nself.switch_backdrop(\"sunny\")\n```\n\nIf you want to use a *number* to say which backdrop, remember that Python starts counting entries in a list at *zero*.\n\n```\n# Switch to first backdrop:\nself.switch_backdrop(0)\n```\n\n```\n# Switch to second backdrop:\nself.switch_backdrop(1)\n```"
    },
    {
        "kind": "block",
        "python": "self.next_costume(n_steps=1)",
        "scratch": "next costume",
        "help": "**Sprites only:** Without `n_steps`, switch the `self` Sprite to the costume after the current one in the `Costumes` list.  If the Sprite was already wearing the last costume in the list, then switch back to the first one in the list.\n\n```\n# Switch to next costume:\nself.next_costume()\n```\n\nYou can also go forward more than one costume, or go *backwards* in the `Costumes` list, by giving `n_steps`.  With this usage, the `self` Sprite will switch to the costume `n_steps` after the current one.  If this would take the Sprite beyond the end of its `Costumes` list, then loop round to the start of the list, as if it was arranged in a circle.\n\n```\n# Switch to next-but-one costume:\nself.next_costume(2)\n```\n\nUse a negative number for `n_steps` to switch to an *earlier* costume in the list.\n\n```\n# Switch to previous costume:\nself.next_costume(-1)\n```"
    },
    {
        "kind": "block",
        "python": "self.next_backdrop(n_steps=1)",
        "scratch": "next backdrop",
        "help": "**Stage only:** Without `n_steps`, switch your Stage to the backdrop after the current one in the `Backdrops` list.  If the Stage was already showing the last backdrop in the list, then switch back to the first one in the list.\n\n```\n# Switch to next backdrop:\nself.next_backdrop()\n```\n\nYou can also go forward more than one backdrop, or go *backwards* in the `Backdrops` list, by giving `n_steps`.  With this usage, your Stage will switch to the backdrop `n_steps` after the current one.  If this would take the Stage beyond the end of its `Backdrops` list, then loop round to the start of the list, as if it was arranged in a circle.\n\n```\n# Switch to next-but-one backdrop:\nself.next_backdrop(2)\n```\n\nUse a negative number for `n_steps` to switch to an *earlier* backdrop in the list.\n\n```\n# Switch to previous backdrop:\nself.next_backdrop(-1)\n```"
    },
    {
        "kind": "block",
        "python": "self.set_size(size)",
        "scratch": "set size to (75) %",
        "help": "**Sprites only:** Set the `self` Sprite's size to `size`.  Scratch uses percentages for sizes, but in Pytch, `1` means the Sprite's normal size, `0.5` means half size, `2` means double size, and so on.\n\n```\n# Become three-quarter size:\nself.set_size(0.75)\n```"
    },
    {
        "kind": "block",
        "python": "self.show()",
        "scratch": "show",
        "help": "**Sprites only:** Make the `self` Sprite visible.\n\n```\n# Appear:\nself.show()\n```"
    },
    {
        "kind": "block",
        "python": "self.hide()",
        "scratch": "hide",
        "help": "**Sprites only:** Make the `self` Sprite invisible.\n\n```\n# Disappear:\nself.hide()\n```"
    },
    {
        "kind": "block",
        "python": "self.go_to_front_layer()",
        "scratch": "go to [front v] layer",
        "help": "**Sprites only:** Move the `self` Sprite to the front drawing layer, making it appear 'closer' to the player than everything else.\n\n```\n# Move in front of everything:\nself.go_to_front_layer()\n```"
    },
    {
        "kind": "block",
        "python": "self.go_to_back_layer()",
        "scratch": "go to [back v] layer",
        "help": "**Sprites only:** Move the `self` Sprite to the back drawing layer, making it appear 'further' from the player than everything else.\n\n```\n# Move behind everything:\nself.go_to_back_layer()\n```"
    },
    {
        "kind": "block",
        "python": "self.go_forward_layers(n_layers)",
        "scratch": "go [forward v] (3) layers",
        "help": "**Sprites only:** Move the `self` Sprite `n_layers` layers forwards in the drawing order, appearing 'closer' to the player.\n\n```\n# Move three layers nearer front:\nself.go_forward_layers(3)\n```"
    },
    {
        "kind": "block",
        "python": "self.go_backward_layers(n_layers)",
        "scratch": "go [backward v] (4) layers",
        "help": "**Sprites only:** Move the `self` Sprite `n_layers` layers backwards in the drawing order, appearing 'further' from the player.\n\n```\n# Move four layers nearer back:\nself.go_backward_layers(4)\n```"
    },
    {
        "kind": "block",
        "python": "self.costume_number",
        "scratch": "(costume (number v))",
        "help": "**Sprites only:** The position in its `Costumes` list of the costume which the `self` Sprite is wearing.  Remember that Python counts list entries starting from *zero*. For example, if a Sprite is wearing its *third* costume, `self.costume_number` will be `2`.\n\n```\n# Say my costume number:\nself.say(self.costume_number)\n```"
    },
    {
        "kind": "block",
        "python": "self.backdrop_number",
        "scratch": "(backdrop (number v))",
        "help": "**Stage only:** The position in its `Backdrops` list of the backdrop your Stage is showing.  Remember that Python counts list entries starting from *zero*. For example, if the Stage is showing its *third* backdrop, `self.backdrop_number` will be `2`.\n\n```\n# Print my backdrop number\n# to the \"Output\" pane:\nprint(self.backdrop_number)\n```"
    },
    {
        "kind": "block",
        "python": "self.costume_name",
        "scratch": "(costume (name v))",
        "help": "**Sprites only:** The name of the costume which the `self` Sprite is wearing.\n\n```\n# Print my costume name to the\n# \"Output\" pane:\nprint(self.costume_name)\n```"
    },
    {
        "kind": "block",
        "python": "self.backdrop_name",
        "scratch": "(backdrop (name v))",
        "help": "**Stage only:** The name of the backdrop which the Stage is showing.\n\n```\n# Print my backdrop name to the\n# \"Output\" pane:\nprint(self.backdrop_name)\n```"
    },
    {
        "kind": "block",
        "python": "self.size",
        "scratch": "(size)",
        "help": "**Sprite only:** The current size of the `self` Sprite, where `1` is full size, `0.5` is half-size, `2` is double-size, and so on.\n\n```\n# Say how big I am:\nself.say(self.size)\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "sound",
        "heading": "Sound"
    },
    {
        "kind": "block",
        "python": "self.play_sound_until_done(sound)",
        "scratch": "play sound (splash v) until done",
        "help": "Start the sound called `sound` playing.  This method will not return until the entire sound has played, so the method it is part of will not move on to its next statement until the sound is done playing.\n\n```\n# Make noise, then disappear:\nself.play_sound_until_done(\"splash\")\nself.hide()\n```"
    },
    {
        "kind": "block",
        "python": "self.start_sound(sound)",
        "scratch": "start sound (my-song v)",
        "help": "Start the sound called `sound` playing.  Once the sound has started, the Sprite will straight away move on to the next statement in your method.\n\n```\n# Start playing tune, and glide\n# to centre while tune is playing:\nself.start_sound(\"my-song\")\nself.glide_to_xy(0, 0, 1.5)\n```"
    },
    {
        "kind": "block",
        "python": "self.set_sound_volume(volume)",
        "scratch": "set volume to [25] %",
        "help": "Set the volume for sounds being played by the `self` Sprite (or Stage).  Volume values are measured between `0` (silence) and `1` (full volume), which is different from Scratch, which measures between `0%` and `100%`.\n\n```\n# Play fairly quietly:\nself.set_sound_volume(0.25)\n```"
    },
    {
        "kind": "block",
        "python": "self.change_sound_volume(d_volume)",
        "scratch": "change volume by [10]",
        "help": "Increase the volume for sounds being played by the `self` Sprite (or Stage) by the given amount (or decrease the volume, if `d_volume` is negative).    Volume values are measured between `0` (silence) and `1` (full volume), which is different from Scratch, which measures between `0%` and `100%`.\n\n```\n# Play a bit more loudly:\nself.change_sound_volume(0.1)\n```"
    },
    {
        "kind": "block",
        "python": "self.sound_volume",
        "scratch": "(volume)",
        "help": "The current volume for sounds played by the `self` Sprite (or Stage).  Volume values are measured between `0` (silence) and `1` (full volume), which is different from Scratch, which measures between `0%` and `100%`.\n\n```\n# Say how loud I am:\nself.say(self.sound_volume)\n```"
    },
    {
        "kind": "block",
        "python": "pytch.stop_all_sounds()",
        "scratch": "stop all sounds",
        "help": "Stop all sounds that are currently playing.\n\n```\n# Make everybody be quiet:\npytch.stop_all_sounds()\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "events",
        "heading": "Events"
    },
    {
        "kind": "block",
        "python": "@pytch.when_green_flag_clicked",
        "scratch": "when green flag clicked",
        "help": {
            "flat": "Ask Pytch to run the method below whenever the green flag is clicked by the player.\n\n```\n# Move to correct position\n# when game starts:\n@pytch.when_green_flag_clicked\ndef go_to_start_position(self):\n    self.go_to_xy(20, 20)\n```",
            "per-method": "Ask Pytch to run code whenever the green flag is clicked by the player."
        }
    },
    {
        "kind": "block",
        "python": "@pytch.when_key_pressed(key_name)",
        "scratch": "when [b v] key pressed",
        "help": {
            "flat": "Ask Pytch to run the method below whenever the player presses the `key_name` key.\n\n```\n# Bark when player presses \"b\" key:\n@pytch.when_key_pressed(\"b\")\ndef bark(self):\n    self.start_sound(\"woof\")\n```",
            "per-method": "Ask Pytch to run code whenever the player presses a particular key."
        }
    },
    {
        "kind": "block",
        "python": "@pytch.when_this_sprite_clicked",
        "scratch": "when this sprite clicked",
        "help": {
            "flat": "**Sprites only:** Ask Pytch to run the method below whenever the player clicks on this Sprite.\n\n```\n# Disappear if player clicks on me:\n@pytch.when_this_sprite_clicked\ndef disappear(self):\n    self.hide()\n```",
            "per-method": "**Sprites only:** Ask Pytch to run code whenever the player clicks on this Sprite."
        }
    },
    {
        "kind": "block",
        "python": "@pytch.when_stage_clicked",
        "scratch": "when stage clicked",
        "help": {
            "flat": "**Stage only:** Ask Pytch to run the method below whenever the player clicks on the Stage.\n\n```\n# Make noise if player clicks on\n# the Stage:\n@pytch.when_stage_clicked\ndef beep(self):\n    self.start_sound(\"beep\")\n```",
            "per-method": "**Stage only:** Ask Pytch to run code whenever the player clicks on the Stage."
        }
    },
    {
        "kind": "block",
        "python": "@pytch.when_I_receive(message)",
        "scratch": "when I receive [pop v]",
        "help": {
            "flat": "Ask Pytch to run the method below whenever any Sprite (or the Stage) broadcasts the `message`.\n\n```\n# Give player a point when they\n# pop a bubble:\n@pytch_when_I_receive(\"pop\")\ndef give_player_point(self):\n    self.score += 1\n    self.say(self.score)\n```",
            "per-method": "Ask Pytch to run code whenever any Sprite (or the Stage) broadcasts a particular message."
        }
    },
    {
        "kind": "block",
        "python": "pytch.broadcast(message)",
        "scratch": "broadcast [caught-cat v]",
        "help": {
            "flat": "Broadcast the `message`.  This makes any methods with matching `@pytch.when_I_receive()` run.  Your method immediately continues running after the message has been sent.\n\n```\n# Tell cat it has been caught, and\n# straight away start barking:\npytch.broadcast(\"caught-cat\")\nself.start_sound(\"woof\")\n```",
            "per-method": "Broadcast the `message`.  This runs any code under a matching *when I receive* hat block.  Your code immediately continues running after the message has been sent."
        }
    },
    {
        "kind": "block",
        "python": "pytch.broadcast_and_wait(message)",
        "scratch": "broadcast [dance v] and wait",
        "help": {
            "flat": "Broadcast the `message`.  This makes any methods with matching `@pytch.when_I_receive()` run.  Your method then waits until all methods which have responded to that message have finished running.\n\n```\n# Tell the dog to dance, and then\n# praise it when it has finished:\npytch.broadcast_and_wait(\"dance\")\nself.say(\"Very good!\")\n```",
            "per-method": "Broadcast the `message`.  This runs any code under a matching *when I receive* hat block.  Your code then waits until all code which has responded to that message has finished running."
        }
    },

    {
        "kind": "heading",
        "sectionSlug": "control",
        "heading": "Control"
    },
    {
        "kind": "block",
        "python": "pytch.wait_seconds(seconds)",
        "scratch": "wait [0.5] seconds",
        "help": "Pause your method for `seconds` seconds.\n\n```\n# Wait for half a second:\npytch.wait_seconds(0.5)\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "Repeat",
        "scratch": "repeat (10)\nend",
        "python": "for i in range(n_times):\n    your_code()",
        "help": "Run the indented code block the given number of times.  In Python, you can use the *loop variable* inside the block — it counts from zero up to one less than the number of times the loop runs, inclusive.\n\n```\n# Count from zero up to nine:\nfor i in range(10):\n    self.say_for_seconds(i, 1)\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "Forever",
        "scratch": "forever\nend",
        "python": "while True:\n    your_code()",
        "help": "Run the indented block of code round and round forever.\n\n```\n# Make sure I am always saying the\n# right score:\nwhile True:\n    self.say(score)\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "If/then",
        "scratch": "if <[n-apples] = (1)> then",
        "python": "if your_test:\n    code_to_run_if_test_true()",
        "help": "Check whether `your_test` is true.  If (and only if) it is true, the indented code block runs.\n\n```\n# Show warning if one apple left:\nif n_apples == 1:\n    self.say(\"Last apple!\")\n\n# No matter how many apples left,\n# glide back to centre:\nself.glide_to_xy(0, 0, 1.5)\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "If/then/else",
        "scratch": "if <(score) > (bot-score)> then\nelse",
        "python": "if your_test:\n    code_to_run_if_test_true()\nelse:\n    code_to_run_if_test_false()",
        "help": "Check whether `your_test` is true.  If (and only if) it is, the first indented code block runs.  Otherwise, the second indented code block runs\n\n```\n# Choose costume according to\n# whether player is winning:\nif score > bot_score:\n    self.switch_costume(\"happy\")\nelse:\n    self.switch_costume(\"sad\")\n```\n\nIn Python, you can have more than one test, by using `elif`, which is short for *else if*.  Each test is checked in turn, looking for the first one which is true — then its indented code runs.  If no test is true, the `else` indented code runs.\n\n```# Say how well the player did:\nif score >= 20:\n    self.say(\"Excellent!\")\nelif score >= 10:\n    self.say(\"Good!\")\nelse:\n    self.say(\"Keep trying!\")\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "Repeat until",
        "scratch": "repeat until <touching (Banana v)?>\nend",
        "python": "while not your_test:\n    your_code()",
        "help": "To get the behaviour of Scratch's *repeat until* block, Python has the `while` statement.  This works the other way round to Scratch's *repeat until* block — Python runs the indented code while the test is *true*, compared to Scratch which runs the contained blocks while the test is *false* (i.e., until it's *true*).  Python's `not` operator can be useful, or you can sometimes rephrase the test instead.\n\n```\n# Move slowly up until I touch\n# the Banana:\nwhile not self.touching(Banana):\n    self.change_y(2)\n```\n\nYou can avoid `not` when using comparison operators — instead of `not n_clicks > 3`, you can say:\n\n```\n# Drift left until I have been\n# clicked more than three times:\nwhile n_clicks <= 3:\n    self.change_x(-2)\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "Wait until",
        "scratch": "wait until <key (d v) pressed?>",
        "python": "while not your_test:\n    pass",
        "help": "To get the behaviour of Scratch's *wait until* block, you treat it like an empty *repeat until*, using Python's `while` statement.  This works the other way round to Scratch's *repeat until* block — Python runs the indented code while the test is *true*, compared to Scratch which runs the contained blocks while the test is *false* (i.e., until it's *true*).  Python's `not` operator can be useful, or you can sometimes rephrase the test instead.\n\nTo get *wait until* behaviour, you can use Python's `pass` statement inside the `while`.  The `pass` does nothing, but it is needed because Python needs *some* indented code for the `while` statement.\n\n```\n# Wait until player presses \"d\":\nwhile not pytch.key_pressed(\"d\"):\n    pass\n```\n\nTo replace *wait until score > 3*, you can avoid having to use `not` by saying:\n```\n# Wait until score > 3:\nwhile score <= 3:\n    pass\n```"
    },
    {
        "kind": "block",
        "python": "return",
        "scratch": "stop [this script v]",
        "help": "Stop running your method.  (Pytch does not have a way to say *stop other scripts in sprite*.)\n\n```\n# If already fully grown, do not\n# do anything else:\nif self.costume_name == \"flower\":\n    return\n\n# Continue growing:\nself.next_costume()\n```"
    },
    {
        "kind": "block",
        "python": "pytch.stop_all()",
        "scratch": "stop [all v]",
        "help": "Stop your whole project, exactly as if you had used the red stop button.  (Pytch does not have a way to say *stop other scripts in sprite*.)\n\n```\n# If the player has got enough\n# points, end the whole game:\nif score == 100:\n    pytch.stop_all()\n```"
    },
    {
        "kind": "block",
        "python": "@pytch.when_I_start_as_a_clone",
        "scratch": "when I start as a clone",
        "help": {
            "flat": "Ask Pytch to run the following method whenever a new clone of the Sprite is created.  In that method, the `self` Sprite is the new clone.\n\n```\n# Make a noise as I appear:\n@pytch.when_I_start_as_a_clone\ndef make_noise(self):\n    self.start_sound(\"ping\")\n```",
            "per-method": "Ask Pytch to run code whenever a new clone of the Sprite is created.  In the code, the `self` Sprite is the new clone."
        }
    },
    {
        "kind": "block",
        "python": "pytch.create_clone_of(self)",
        "scratch": "create clone of [myself v]",
        "help": "Create a new clone of the `self` Sprite.  Any `@pytch.when_I_start_as_a_clone` methods will run for that new clone.\n\n```\n# Make two extra copies of myself\n# across stage:\npytch.create_clone_of(self)\nself.change_x(50)\npytch.create_clone_of(self)\nself.change_x(50)\n```"
    },
    {
        "kind": "block",
        "python": "pytch.create_clone_of(sprite_class)",
        "scratch": "create clone of [Banana v]",
        "help": "Create a new clone of the `sprite_class` Sprite.  Any `@pytch.when_I_start_as_a_clone` methods will run for that new clone.\n\n```\nclass Apple(pytch.Sprite):\n    @pytch.when_key_pressed(\"n\")\n    def make_new_Banana(self):\n        pytch.create_clone_of(Banana)\n```"
    },
    {
        "kind": "block",
        "python": "self.delete_this_clone()",
        "scratch": "delete this clone",
        "help": "Delete the `self` clone.  If `self` is the *original* of your Sprite (and so is *not* a clone), then nothing happens — you cannot delete the original of a Sprite.\n\n```\n# This clone is not needed any more:\nself.delete_this_clone()\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "sensing",
        "heading": "Sensing"
    },
    {
        "kind": "block",
        "python": "self.touching(sprite_class)",
        "scratch": "<touching [Apple v]>",
        "help": "Report `True` or `False` according to whether the `self` Sprite is touching either the original `sprite_class` Sprite, or any `sprite_class` clones (if it has any).\n\n```\n# Hide if touching any Apple:\nif self.touching(Apple):\n    self.hide()\n```"
    },
    {
        "kind": "block",
        "python": "self.ask_and_wait(question)",
        "scratch": "ask [Name?] and wait",
        "help": "Ask the `question`, wait for the player to type in their answer, and report that answer.  Usually you will assign the player's answer to a variable.\n\nIf the `self` Sprite is shown, then the question appears in a speech bubble.  If the `self` Sprite is hidden, the question appears in a box at the bottom of the stage.\n\n```\nname = self.ask_and_wait(\"Name?\")\n```"
    },
    {
        "kind": "block",
        "python": "pytch.key_pressed(key_name)",
        "scratch": "<key (a v) pressed?>",
        "help": "Report `True` or `False` according to whether the player is currently pressing the `key_name` key.\n\n```\n# Choose costume based on whether\n# the \"a\" key is pressed:\nif pytch.key_pressed(\"a\"):\n    self.switch_costume(\"flying\")\nelse:\n    self.switch_costume(\"walking\")\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "operators",
        "heading": "Operators"
    },
    {
        "kind": "block",
        "python": "value_1 + value_2",
        "scratch": "((n-apples) + (n-oranges))",
        "help": "Give the result of adding the two values together.\n\n```\n# Find total number of pieces of\n# fruit found by the player:\nn_fruits = n_apples + n_oranges\n```"
    },
    {
        "kind": "block",
        "python": "value_1 - value_2",
        "scratch": "((health) - [1])",
        "help": "Give the result of subtracting the second value from the first.\n\n```\n# The player lost a health point:\nnew_health = health - 1\n```"
    },
    {
        "kind": "block",
        "python": "value_1 * value_2",
        "scratch": "((n_jumps) * [12])",
        "help": "Give the result of multiplying the two values together.\n\n```\n# Each 'jump' is of size 12:\ndistance = n_jumps * 12\n```"
    },
    {
        "kind": "block",
        "python": "value_1 / value_2",
        "scratch": "((score) / [20])",
        "help": "Give the result of dividing the first value by the second.  The result can include a decimal part if the first number does not divide exactly by the second.\n\n```\n# Make myself bigger the higher the\n# player's score is, with a score of\n# 20 being full size:\nself.set_size(score / 20)\n```\n\nIf you are working with whole numbers and want to ignore any remainder, you can use Python's `//` operator:\n\n```\n# Award one star for every 50 points:\nn_stars = score // 50\n```"
    },
    {
        "kind": "block",
        "python": "random.randint(lowest, highest)",
        "scratch": "(pick random (1) to (6))",
        "help": {
            "flat": "To use this function, you must have the line `import random` at the top of your program, just after the `import pytch` line.\n\nPick a random whole number from `lowest` to `highest`, inclusive.\n\n```\n# Pretend to roll a 6-sided die:\nroll = random.randint(1, 6)\n```",
            "per-method": "Pick a random whole number from `lowest` to `highest`, inclusive.\n\n```\n# Pretend to roll a 6-sided die:\nroll = random.randint(1, 6)\n```"
        }
    },
    {
        "kind": "block",
        "python": "value_1 > value_2",
        "scratch": "<(score) > [50]>",
        "help": "Report whether the first value is larger than the second value.  You often use this as part of an `if` or `while` statement.\n\n```\n# If player got a good score,\n# congratulate them:\nif score > 50:\n    self.say(\"Well done!\")\n```\n\nPython also has the `>=` operator, which means 'larger than or equal to':\n```\n# If player is at least 1.5m tall,\n# let them play:\nif height >= 1.5:\n    self.say(\"Let's play!\")\n```"
    },
    {
        "kind": "block",
        "python": "value_1 < value_2",
        "scratch": "<(n-apples) < (5)>",
        "help": "Report whether the first value is smaller than the second value.  You often use this as part of an `if` or `while` statement.\n\n```\n# If not many apples left, give\n# message:\nif n_apples < 5:\n    self.say(\"Not many apples left!\")\n```\n\nPython also has the `<=` operator, which means 'smaller than or equal to':\n```\n# If player did not beat the\n# high-score, encourage them:\nif score <= high_score:\n    self.say(\"Try harder!\")\n```"
    },
    {
        "kind": "block",
        "python": "value_1 == value_2",
        "scratch": "<(score) = (bot-score)>",
        "help": "Report whether the first value is equal to the second value.  You must use *two* equals signs for this in Python.  You often use this as part of an `if` or `while` statement.\n\n```\n# If player and bot got the same\n# score, announce a draw:\nif score == bot_score:\n    self.say(\"It's a draw!\")\n```"
    },
    {
        "kind": "block",
        "python": "your_test_1 and your_test_2",
        "scratch": "<<(n-cats) > [3]> and <(n-dogs) > [5]>>",
        "scratchIsLong": true,
        "help": "Report whether *both* tests are true.  You often use this as part of an `if` or `while` statement.\n\n```\n# If more than three cats AND more\n# than five dogs, say message:\nif n_cats > 3 and n_dogs > 5:\n    self.say(\"Lots of animals!\")\n```"
    },
    {
        "kind": "block",
        "python": "your_test_1 or your_test_2",
        "scratch": "<<(height) < [10]> or <(speed) > [20]>>",
        "scratchIsLong": true,
        "help": "Report whether the first test *or* the second test (*or* both) is true.  You often use this as part of an `if` or `while` statement.\n\n```\n# If player too low or too fast,\n# warn them:\nif height < 10 or speed > 20:\n    self.say(\"Watch out!\")\n```"
    },
    {
        "kind": "block",
        "python": "not your_test",
        "scratch": "<not <touching (Dog v) ?>",
        "help": "Report whether `your_test` is *false*.  You often use this as part of an `if` or `while` statement.\n\n```\n# If I am not touching the dog,\n# give player instruction:\nif not self.touching(Dog):\n    self.say(\"Go to the dog!\")\n```"
    },
    {
        "kind": "block",
        "python": "string_value_1 + string_value_2",
        "scratch": "(join [Hello, ] (name))",
        "help": "Give the result of joining two strings together.\n\n```\n# Greet player:\nself.say(\"Hello, \" + name)\n```\n\nIn Python, you can easily join more than two strings together:\n\n```\n# Announce winner:\nself.say_for_seconds(\"Game over\", 1)\nself.say(\"and \" + name + \" won!\")\n```\n"
    },
    {
        "kind": "block",
        "python": "string_value[index]",
        "scratch": "(letter [3] of (name))",
        "help": "Give the letter (or number, or other character) at position `index` of the `string_value`.  Remember that Python starts counting at *zero*, so to get the first letter use `0` for `index`; to get the third letter, use `2` for `index`, and so on.\n\n```\n# Say the third letter of the\n# player's name:\nself.say(name[2])\n```"
    },
    {
        "kind": "block",
        "python": "len(string_value)",
        "scratch": "(length of (name))",
        "help": "Give the number of letters (or numbers, or other characters) in the `string_value`.\n\n```\n# Tell the player how long their\n# name is:\nself.say(len(name))\n```"
    },
    {
        "kind": "block",
        "python": "letters in string_value",
        "scratch": "<(colour) contains [lu] ?>",
        "help": "Report whether the `string_value` contains the string of `letters`.  You often use this as part of an `if` or `while` statement.\n\n```\n# If the player's favourite colour has\n# \"lu\" in it, say so:\nif \"lu\" in colour:\n    self.say(\"That has LU in\")\n```\n\nAn important difference is that Scratch ignores whether the letters are capitals or lower case, but in Python, \"A\" is different to \"a\"."
    },
    {
        "kind": "block",
        "python": "value_1 % value_2",
        "scratch": "((n-eggs) mod [12])",
        "help": "Give the remainder after dividing `value_1` by `value_2`.\n\n```\n# Say how many loose eggs left over\n# after putting into boxes of 12:\nself.say(n_eggs % 12)\n```"
    },
    {
        "kind": "block",
        "python": "round(value)",
        "scratch": "(round (journey-length))",
        "help": "Give the nearest whole number to `value`.\n\n```\n# Tell player the length of their\n# journey to the nearest whole km:\nself.say(round(journey_length))\n```"
    },
    {
        "kind": "non-method-block",
        "heading": "Mathematical functions",
        "scratch": "([abs v] of (value))",
        "help": {
            "flat": "Work out a mathematical function of the `value`.  In Python, you use these function:\n* `abs(x)` — Scratch's *abs of x*\n* `math.floor(x)` — *floor of x*\n* `math.ceil(x)` — *ceiling of x*\n* `math.sqrt(x)` — *sqrt of x*\n* `math.sin(x)` — *sin of x* — (✻)\n* `math.cos(x)` — *cos of x* — (✻)\n* `math.tan(x)` — *tan of x* — (✻)\n* `math.asin(x)` — *asin of x* — (✻)\n* `math.acos(x)` — *acos of x* — (✻)\n* `math.atan(x)` — *atan of x* — (✻)\n* `math.log(x)` — *ln of x*\n* `math.log10(x)` — *log of x*\n* `math.exp(x)` — *e ^ x*\n* `10 ** x` — *10 ^ x*\n\nTo use the functions starting with `math.`, you must have the line `import math` at the top of your program, after the `import pytch` line.\n\n(✻) An important difference is that Scratch's trigonometry functions work in *degrees* but Python's work in *radians*.",
            "per-method": "Work out a mathematical function of the `value`.  In Python, you use these function:\n* `abs(x)` — Scratch's *abs of x*\n* `math.floor(x)` — *floor of x*\n* `math.ceil(x)` — *ceiling of x*\n* `math.sqrt(x)` — *sqrt of x*\n* `math.sin(x)` — *sin of x* — (✻)\n* `math.cos(x)` — *cos of x* — (✻)\n* `math.tan(x)` — *tan of x* — (✻)\n* `math.asin(x)` — *asin of x* — (✻)\n* `math.acos(x)` — *acos of x* — (✻)\n* `math.atan(x)` — *atan of x* — (✻)\n* `math.log(x)` — *ln of x*\n* `math.log10(x)` — *log of x*\n* `math.exp(x)` — *e ^ x*\n* `10 ** x` — *10 ^ x*\n\n(✻) An important difference is that Scratch's trigonometry functions work in *degrees* but Python's work in *radians*."
        }
    },

    {
        "kind": "heading",
        "sectionSlug": "variables",
        "heading": "Working with variables"
    },
    {
        "kind": "block",
        "python": "variable = value",
        "scratch": "set [n-apples v] to [5]",
        "help": "Make `variable` refer to `value`.\n\n```\n# Set the starting number of apples:\nn_apples = 5\n```"
    },
    {
        "kind": "block",
        "python": "variable += value_increase",
        "scratch": "change [n-pears v] by [3]",
        "help": "Add `value_increase` to the value currently referred to by `variable`.\n\n```\n# The player got three more pears:\nn_pears += 3\n```\n\nIf you want to *decrease* a variable, you can use the `-=` operator.\n\n```\n# The player lost two bananas:\nn_bananas -= 2\n```\n\nYou can use `*=` and `/=` in a similar way.\n\nIn Python, the `+` operator can join strings or lists as well as add numbers, and the `+=` operator works the same.\n\n```\n# Build up greeting:\ngreeting = \"Hello, \"\ngreeting += player_name\n```"
    },
    {
        "kind": "block",
        "python": "pytch.show_variable(owner, var_name)",
        "scratch": "show variable [health v]",
        "help": "Display a variable-watcher for the variable called `var_name` belonging to `owner`.  Often, `owner` will be the `self` Sprite, and usually `var_name` will be a literal string, being the name of the variable you would like to show.  A particular variable is only ever shown once, even if `show_variable()` is called many times for that variable.\n\n```\n# Show my health:\npytch.show_variable(self, \"health\")\n```\n\nTo show a global variable, use `None` for `owner`.\n\n```\n# Show the global \"score\" variable:\npytch.show_variable(None, \"score\")\n```"
    },
    {
        "kind": "block",
        "python": "pytch.hide_variable(owner, var_name)",
        "scratch": "hide variable [hi-score v]",
        "help": "Hide the variable-watcher for the variable called `var_name` belonging to `owner`, if such a watcher exists.  If that variable is not being shown, do nothing.\n\nOften, `owner` will be the `self` Sprite, and usually `var_name` will be a literal string, being the name of the variable you would like to hide.\n\n```\n# Hide the high score:\npytch.hide_variable(self, \"hi_score\")\n```\n\nTo hide a global variable, use `None` for `owner`.\n\n```\n# Hide the global \"score\" variable:\npytch.hide_variable(None, \"score\")\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "lists",
        "heading": "Working with lists"
    },
    {
        "kind": "block",
        "python": "things.append(thing)",
        "scratch": "add [large] to [sizes v]",
        "help": "Add the `thing` as a new entry at the end of the list `things`.\n\n```\n# Record another size:\nsizes.append(\"large\")\n```"
    },
    {
        "kind": "block",
        "python": "del things[index]",
        "scratch": "delete [3] of [colours v]",
        "help": "Delete the entry at position `index` from the list `things`.  Remember that Python starts counting at *zero*, so to delete the *second* element of a list, `index` should be `1`, and so on.\n\n```\n# Delete the third colour:\ndel colours[2]\n```"
    },
    {
        "kind": "block",
        "python": "del things[:]",
        "scratch": "delete all of [high-scores v]",
        "help": "Delete all entries of the list `things`.\n\n```\n# Forget all high scores:\ndel high_scores[:]\n```"
    },
    {
        "kind": "block",
        "python": "things.insert(index, thing)",
        "scratch": "insert [basketball] at [1] of [sports v]",
        "scratchIsLong": true,
        "help": "Insert a new entry `thing` into the list `things`, so that `thing` ends up at position `index`.  Remember that Python starts counting at *zero*, so to insert a new entry in the *second* place of the list, `index` should be `1`, and so on.\n\n```\n# Add \"basketball\" at very start of\n# list of sports:\nsports.insert(0, \"basketball\")\n```"
    },
    {
        "kind": "block",
        "python": "things[index] = new_thing",
        "scratch": "replace item [3] of [flowers v] with [rose]",
        "scratchIsLong": true,
        "help": "Replace the entry at position `index` in the list `things` with `new_thing`.  Remember that Python starts counting at *zero*, so to replace the *second* element of a list, `index` should be `1`, and so on.\n\n```\n# Replace third flower with a rose:\nflowers[2] = \"rose\"\n```"
    },
    {
        "kind": "block",
        "python": "things[index]",
        "scratch": "item [2] of [animals v]",
        "help": "Give the element at position `index` in the list `things`.  Remember that Python starts counting at *zero*, so to get the *second* element of a list, `index` should be `1`, and so on.\n\n```\n# Announce the second animal:\nself.say(animals[1])\n```"
    },
    {
        "kind": "block",
        "python": "things.index(thing)",
        "scratch": "(item # of [apple] in [fruits v])",
        "help": "Report the smallest index where `thing` can be found in the list `things`.  Remember that Python starts counting at *zero*, so if `thing` is the *second* element of the list, the value `1` will be reported.\n\n```\n# Say which fruit is the apple:\nself.say(fruits.index(\"apple\"))\n```\n\nScratch reports `0` if `thing` is not in the list, but Python *raises an exception*."
    },
    {
        "kind": "block",
        "python": "len(things)",
        "scratch": "(length of [vegetables v])",
        "help": "Report the number of elements in the list `things`.  This will be zero if the list is empty.\n\n```\n# Say how many vegetables there are:\nself.say(len(vegetables))\n```"
    },
    {
        "kind": "block",
        "python": "thing in things",
        "scratch": "<[patterns v] contains [dots]?>",
        "help": "Report (as `True` or `False`) whether the list `things` contains `thing`.\n\n```\n# Beep if \"dots\" is one of the\n# patterns:\nif \"dots\" in patterns:\n    self.start_sound(\"beep\")\n```"
    },

    {
        "kind": "heading",
        "sectionSlug": "instances",
        "heading": "Sprites, clones, and the Stage"
    },
    {
        "kind": "pure-python",
        "python": "cls.the_original()",
        "help": "Give the original instance of the Sprite class `cls`.\n\n```\n# Say which costume the original Dog\n# is wearing:\nthe_dog = Dog.the_original()\nself.say(the_dog.costume_name)\n```"
    },
    {
        "kind": "pure-python",
        "python": "cls.all_clones()",
        "help": "Give a list of all clones of the Sprite class `cls`.  If `cls` has no clones, the list will be empty.\n\n```\n# Say how many Cat clones there are:\nself.say(len(Cat.all_clones()))\n```"
    },
    {
        "kind": "pure-python",
        "python": "cls.all_instances()",
        "help": "Give a list of all instances of the Sprite class `cls`.  The first element of the list will be the original `cls`, followed by any clones.  If `cls` has no clones, the list will contain just one element, i.e., the original `cls`.\n\n```\n# Say how many Apples there are\n# altogether:\nself.say(len(Apple.all_instances()))\n```"
    },
    {
        "kind": "pure-python",
        "python": "stage_cls.the_only()",
        "help": "Give the only instance of the Stage class `stage_cls`.\n\n```\n# Say which backdrop the stage\n# is showing:\nthe_sky = Sky.the_only()\nself.say(the_sky.costume_name)\n```"
    }
]
